package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/Mikhalevich/argparser"
	"github.com/Mikhalevich/goauth"
	"github.com/Mikhalevich/goauth/db"
	"github.com/Mikhalevich/goauth/email"
	"github.com/Mikhalevich/goauth/session"
)

var (
	auth *goauth.Authentificator
)

type DBParams struct {
	User     string `json:"user"`
	Password string `json:"pwd"`
	DBName   string `json:"db_name"`
	Host     string `json:"host"`
	Port     int    `json:"port"`
	SSLMode  string `json:"sslmode"`
}

func NewDBParams() *DBParams {
	return &DBParams{
		User:     "postgres",
		Password: "",
		DBName:   "Test",
		Host:     "localhost",
		Port:     5432,
		SSLMode:  "disable",
	}
}

func (p DBParams) connectionString() string {
	return fmt.Sprintf("user=%s password=%s dbname=%s host=%s port=%d sslmode=%s", p.User, p.Password, p.DBName, p.Host, p.Port, p.SSLMode)
}

type Params struct {
	DB DBParams `json:"db"`
}

func NewParams() *Params {
	return &Params{
		DB: *NewDBParams(),
	}
}

func loadParams() (*Params, error) {
	basicParams := NewParams()
	parser := argparser.NewParser()
	params, err, gen := parser.Parse(basicParams)

	if gen {
		return nil, errors.New("config should be autogenerated")
	}

	return params.(*Params), err
}

func rootHandler(w http.ResponseWriter, r *http.Request) {
	user := r.Context().Value("user").(*goauth.User)
	fmt.Fprintf(w, "authentificated with user: %s", user.Name)
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
	userInfo := NewTemplatePassword()
	renderTemplate := true
	defer func() {
		if renderTemplate {
			if err := userInfo.Execute(w); err != nil {
				log.Println(err)
			}
		}
	}()

	if r.Method != http.MethodPost {
		return
	}

	userInfo.Name = r.FormValue("name")
	userInfo.Password = r.FormValue("password")

	if userInfo.Name == "" {
		userInfo.AddError("name", "Please specify storage name to login")
	}

	if userInfo.Password == "" {
		userInfo.AddError("password", "Please enter password to login")
	}

	if len(userInfo.Errors) > 0 {
		return
	}

	session, err := auth.AuthorizeByName(userInfo.Name, userInfo.Password, r.RemoteAddr)
	if err != nil {
		userInfo.AddError("name", err.Error())
		return
	}

	renderTemplate = false
	cookie := http.Cookie{Name: session.Name, Value: session.Value, Path: "/", Expires: time.Unix(session.Expires, 0), HttpOnly: true}
	http.SetCookie(w, &cookie)
	http.Redirect(w, r, "/", http.StatusFound)
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
	userInfo := NewTemplateRegister()
	renderTemplate := true
	defer func() {
		if renderTemplate {
			if err := userInfo.Execute(w); err != nil {
				log.Println(err)
			}
		}
	}()

	if r.Method != http.MethodPost {
		return
	}

	userInfo.Name = r.FormValue("name")
	userInfo.Password = r.FormValue("password")

	if userInfo.Name == "" {
		userInfo.AddError("name", "Please specify storage name to login")
	}

	if userInfo.Password == "" {
		userInfo.AddError("password", "Please enter password to login")
	}

	if len(userInfo.Errors) > 0 {
		return
	}

	session, err := auth.RegisterByName(userInfo.Name, userInfo.Password)
	if err != nil {
		userInfo.AddError("name", err.Error())
		return
	}

	renderTemplate = false
	cookie := http.Cookie{Name: session.Name, Value: session.Value, Path: "/", Expires: time.Unix(session.Expires, 0), HttpOnly: true}
	http.SetCookie(w, &cookie)
	http.Redirect(w, r, "/", http.StatusFound)
}

func verifyEmailHandler(w http.ResponseWriter, r *http.Request) {
	userInfo := NewTemplateRegister()
	renderTemplate := true
	defer func() {
		if renderTemplate {
			if err := userInfo.Execute(w); err != nil {
				log.Println(err)
			}
		}
	}()

	if r.Method != http.MethodPost {
		return
	}

	user := r.Context().Value("user").(*goauth.User)

	userInfo.Name = r.FormValue("name")

	if userInfo.Name == "" {
		userInfo.AddError("name", "Please specify email for verification")
	}

	if len(userInfo.Errors) > 0 {
		return
	}

	e := goauth.Email{
		Email: userInfo.Name,
	}

	err := auth.SendEmailVerificationCode("http://127.0.0.1:8080/verify_email_response", user.ID, e)
	if err != nil {
		userInfo.AddError("common", err.Error())
		return
	}

	renderTemplate = false
}

func verifyEmailResponseHandler(w http.ResponseWriter, r *http.Request) {
	email := r.FormValue("email")
	code := r.FormValue("code")

	err := auth.ValidateEmail(email, code)
	if err != nil {
		fmt.Fprintf(w, "error occured: %s", err)
		return
	}

	fmt.Fprintf(w, "email %s verified with code %s", email, code)
}

func checkAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user, err := auth.GetUser(r)
		if err != nil {
			http.Redirect(w, r, "/login", http.StatusFound)
			return
		}

		r = r.WithContext(context.WithValue(r.Context(), "user", user))

		next.ServeHTTP(w, r)
	})
}

func main() {
	params, err := loadParams()
	if err != nil {
		fmt.Println(err)
		return
	}

	time.Sleep(time.Millisecond * 1000)
	pg, err := db.NewPostgres(db.PGParams{DBName: params.DB.DBName, User: params.DB.User, Password: params.DB.Password, Host: params.DB.Host, Port: params.DB.Port, SSLMode: params.DB.SSLMode})
	if err != nil {
		fmt.Println(err)
		return
	}
	defer pg.Close()

	es := &email.GomailSender{
		Host:     "smtp.gmail.com",
		Port:     587,
		From:     "noreplymgoauth@gmail.com",
		Password: "mgoauth123",
	}
	auth = goauth.NewAuthentificator(pg, pg, session.NewCookieSession("test", 5*60), es)

	http.Handle("/", checkAuth(http.HandlerFunc(rootHandler)))
	http.HandleFunc("/login", loginHandler)
	http.HandleFunc("/register", registerHandler)
	http.Handle("/verify_email", checkAuth(http.HandlerFunc(verifyEmailHandler)))
	http.HandleFunc("/verify_email_response", verifyEmailResponseHandler)
	http.ListenAndServe(":8080", nil)
}
